# This file contains functions used for: navigating between folders, tracking history of navigated folders, adding dirs to favorites menu, etc.
scriptDir=~; #get script directory in order to build the paths of the supporting files
prevDir=''; #this variable is used both by the goto function and the function that jumps to previous directory
#
input_storage_file=$scriptDir/.store_input; # temporary solution for getting the user input from the python scripts connected to .functions_goto
output_storage_file=$scriptDir/.store_output; # temporary solution for getting the python script output connected to .functions_goto
#
forwardUserInput=false; #variable used in navigation mode to determine if the user input received by a called function should be processed after function exits
editPrevCommand=false; #variable used for determinining if an entry from command history is fed to the user for editing so a new command is executed based on previous input
#
pythonPath='/usr/bin/python3'

# initialize the environment, ensure the navigation and command history menus are sorted/consolidated
"$pythonPath" "$scriptDir"/init.py
"$pythonPath" "$scriptDir"/consolidate_history.py
"$pythonPath" "$scriptDir"/consolidate_command_history.py

# This function is used for navigating to a new directory; if cd is successful the visited path is memorized into navigation history
function goToDir {
    # Step 1: if an argument was entered check that the argument is valid (entered path exists and is a directory);
    if [[ ! -z $1 ]] && [[ ! -d $1 ]]; then
	if [[ -e $1 ]]; then
	    echo "$1 is not a directory.";
	    return 1;
	fi
	echo "Invalid directory $1";
	echo 'Either is the name invalid (please check spelling) or the directory has been deleted.';
	return 1;  
    fi
    # Step 2: memorize current directory and cd to the new directory (if no argument had been entered, cd to the user home directory)
    prevDir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
    if [[ -z $1 ]]; then
	cd ~ ;
    else
	cd "$1";
    fi
    # Step 3: check if the cd operation has been successful
    if [[ $? != 0 ]]; then 
	echo 'Cannot change directory, the cd command returned an error.';
	echo 'Please try again.';
	return 1;  
    fi
    # Step 4: if cd was done to a different directory than the previous one, update the individual history files and then consolidate recent and persistent history
    currentDir=`pwd`;
    clear;
    echo "Previous directory: $prevDir";
    echo "Opened directory: $currentDir";
    if [[ $currentDir == $prevDir ]]; then
	return 0;
    fi
    "$pythonPath" "$scriptDir"/update_individual_history_files.py "$currentDir"
    "$pythonPath" "$scriptDir"/consolidate_history.py
}

# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
function goToMenu {
    # Step 1: provide input for choosing a path from history/favorites
    if [[ -z "$2" ]]; then
	"$pythonPath" "$scriptDir"/choose_path_from_menu.py "$1";
    else
	"$pythonPath" "$scriptDir"/choose_path_from_menu.py "$1" "$2";
    fi

    # Step 2: handle python script output (navigate only if a valid and existing path has been chosen)
    dirPath=`head -1 $output_storage_file`;
    if [[ "$dirPath" == ":1" ]]; then
	navigationInput=`head -1 $input_storage_file`;
	forwardUserInput=true;
    elif [[ "$dirPath" != ":2" ]] && [[ "$dirPath" != ":3" ]] && [[ "$dirPath" != ":4" ]]; then
	if [[ ! -d "$dirPath" ]]; then
	    "$pythonPath" "$scriptDir"/handle_missing_dir.py "$dirPath" "$1"
	    if [[ `head -1 $output_storage_file` == ":1" ]]; then
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    return 1;
	fi
	goToDir "$dirPath";
    fi
}

# This function is used to enter the directory navigation console (no cd required but only the dir name including wildcards; for commands use ':')
function navigate {
    # accesses the menu with the most recent executed commands, user can choose one entry to execute that command again
    function goToCommandMenu {
	# Step 1: handle user input
	if [[ $editPrevCommand == false ]]; then
	    "$pythonPath" "$scriptDir"/choose_command_from_menu.py --execute
	else
	    "$pythonPath" "$scriptDir"/choose_command_from_menu.py --edit
	fi
	# Step 2: handle python script output (handle command edit/execution only if a valid command has been chosen from menu file)
	commandHistoryEntry=`head -1 $output_storage_file`;
	if [[ "$commandHistoryEntry" == ":1" ]]; then
	    navigationInput=`head -1 $input_storage_file`;
	    forwardUserInput=true;
	elif [[ "$commandHistoryEntry" != ":2" ]] && [[ "$commandHistoryEntry" != ":3" ]] && [[ "$commandHistoryEntry" != ":4" ]]; then
	    if [[ $editPrevCommand == false ]]; then
		# execute the actual command from command history menu
		commandToExecute="$commandHistoryEntry";
		prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
		"$pythonPath" "$scriptDir"/execute_new_command.py "$commandToExecute";
		commandResult=`head -1 $output_storage_file`;
	    else
		# edit the chosen command prior to executing
		editAndExecCmdFromHistory;
	    fi
	fi
    }
    # helper function that feeds a previously executed command (from command history) to user for editing prior to having it executed
    function editAndExecCmdFromHistory {
	echo 'Please edit the below command and hit ENTER to execute';
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$commandHistoryEntry" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
	    "$pythonPath" "$scriptDir"/execute_new_command.py "$commandToExecute";
	    commandResult=`head -1 $output_storage_file`;
	fi
    }
    # helper function for handling general input (new commands or directories to navigate to)
    function handleGeneralInput {
	# A string starting with ':' will be treated as a command (alternative way of entering new commands from navigation mode)
	if [[ ${navigationInput:0:1} == ':' ]]; then
	    commandToExecute=${navigationInput:1};
	    prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
	    "$pythonPath" "$scriptDir"/execute_new_command.py "$commandToExecute";
	    commandResult=`head -1 $output_storage_file`;
	else
	    goToDir `echo "$navigationInput"`;
	fi
    }
    # helper function for executing a new command based on the string of the previously executed shell command
    function execCommandBasedOnPrevInput {
	if [[ -z "$prevCommand" ]]; then
	    echo 'No shell command previously executed. Enter a new command';
	else
	    echo 'Please edit the below command and hit ENTER to execute';
	fi
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$prevCommand" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
	    "$pythonPath" "$scriptDir"/execute_new_command.py "$commandToExecute";
	    commandResult=`head -1 $output_storage_file`;
	fi
    }
    # helper function that handles all possible options entered by user in navigation mode
    function handleNavigationOption {
	case $navigationInput in
	'?')
	    "$pythonPath" "$scriptDir"/display_help.py;
	    ;;
	':-')
	    if [[ -z $prevCommand ]]; then
		echo 'No shell command previously executed';
	    else
		"$pythonPath" "$scriptDir"/execute_new_command.py "$prevCommand";
		commandResult=`head -1 $output_storage_file`;
	    fi
	    ;;
	':')
	    execCommandBasedOnPrevInput;
	    ;;
	':<')
	    editPrevCommand=false;
	    goToCommandMenu;
	    ;;
	'::')
	    editPrevCommand=true;
	    goToCommandMenu;
	    ;;
	':<>')
	    "$pythonPath" "$scriptDir"/clear_command_history.py;
	    ;;
	'<'*)
	    secondArg=${navigationInput:1};
	    goToMenu -h "$secondArg";
	    ;;
	'>'*)
	    secondArg=${navigationInput:1};
	    goToMenu -f "$secondArg";
	    ;;
	',')
	    if [[ $prevDir == '' ]]; then
		echo 'Cannot jump to previous directory.';
		echo 'No directory visited in the current session.';
	    else
		goToDir "$prevDir";
	    fi
	    ;;
	'+>')
	    "$pythonPath" "$scriptDir"/add_dir_to_favorites.py
	    ;;
	'->')
	    "$pythonPath" "$scriptDir"/remove_dir_from_favorites.py;
	    if [[ $? == 2 ]]; then
		# handle the input as "normal" navigation input
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    ;;
	'!<>')
	    "$pythonPath" "$scriptDir"/clear_history.py;
	    ;;
	'!')
	    return 0;
	    ;;
	*)
	    handleGeneralInput;
	    ;;
	esac
    }
    # stores last executed shell command (if any) and its result
    prevCommand='';
    commandResult='';
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	if [[ $navigationInput != "?" ]]; then
	    if [[ -z $prevCommand ]]; then
		"$pythonPath" "$scriptDir"/display_general_navigation_output.py;
	    else
		"$pythonPath" "$scriptDir"/display_general_navigation_output.py "$prevCommand" "$commandResult";
	    fi
	fi
	read -e navigationInput;
	# stay in this loop as long as the function called by choosing a navigation option forwards user input back to the navigate function
	while [[ '1' == '1' ]]; do
	    clear;
	    handleNavigationOption;
	    if [[ $forwardUserInput == true ]]; then
		forwardUserInput=false;
	    else
		break;
	    fi
	done
	if [[ $navigationInput == '!' ]]; then
	    echo 'You exited navigation mode.';
	    unset -f goToCommandMenu;
	    unset -f editAndExecCmdFromHistory;
	    unset -f handleGeneralInput;
	    unset -f execCommandBasedOnPrevInput;
	    unset -f handleNavigationOption;
	    return 0;
	fi
    done
}

# Disable all "private" functions so they cannot be accessed by user from CLI
unset -f goToCommandMenu;
unset -f editAndExecCmdFromHistory;
unset -f execCommandBasedOnPrevInput;
unset -f handleGeneralInput;
unset -f handleNavigationOption;
