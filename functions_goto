# This file contains functions used for: navigating between folders, tracking history of navigated folders, adding dirs to favorites menu, etc.
scriptDir=~; #get script directory in order to build the paths of the supporting files
prevDir=`pwd`; #this variable is used by the function that jumps to previous directory (default is the current directory from which the script launches)
#
input_storage_file=$scriptDir/.store_input; # temporary solution for getting the user input from the python scripts connected to .functions_goto
output_storage_file=$scriptDir/.store_output; # temporary solution for getting the python script output connected to .functions_goto
#
forwardUserInput=false; #variable used in navigation mode to determine if the user input received by a called function should be processed after function exits
#
pythonPath='/usr/bin/python3'

# initialize the environment, ensure the navigation and command history menus are sorted/consolidated
"$pythonPath" "$scriptDir"/init.py
"$pythonPath" "$scriptDir"/consolidate_history.py
"$pythonPath" "$scriptDir"/consolidate_command_history.py

# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
function goToMenu {
    # Step 1: provide input for choosing a path from history/favorites
    if [[ -z "$2" ]]; then
	"$pythonPath" "$scriptDir"/choose_path_from_menu.py "$1";
    else
	"$pythonPath" "$scriptDir"/choose_path_from_menu.py "$1" "$2";
    fi

    # Step 2: handle python script output (navigate only if a valid and existing path has been chosen)
    dirPath=`head -1 $output_storage_file`;
    if [[ "$dirPath" == ":1" ]]; then
	navigationInput=`head -1 $input_storage_file`;
	forwardUserInput=true;
    elif [[ "$dirPath" != ":2" ]] && [[ "$dirPath" != ":3" ]] && [[ "$dirPath" != ":4" ]]; then
	if [[ ! -d "$dirPath" ]]; then
	    "$pythonPath" "$scriptDir"/handle_missing_dir.py "$dirPath" "$1"
	    if [[ `head -1 $output_storage_file` == ":1" ]]; then
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    return 1;
	fi
	"$pythonPath" "$scriptDir"/go_to_dir.py "$dirPath" "$prevDir";
	prevDir=`head -1 $output_storage_file`;
	cd "`head -1 $input_storage_file`";
    fi
}

# This function is used to enter the directory navigation console (no cd required but only the dir name including wildcards; for commands use ':')
function navigate {
    # accesses the menu with the most recent executed commands, user can choose one entry to execute that command again
    function goToCommandMenu {
	# Step 1: handle user input
	"$pythonPath" "$scriptDir"/choose_command_from_menu.py "$1"
	# Step 2: handle python script output (handle command edit/execution only if a valid command has been chosen from menu file)
	commandHistoryEntry=`head -1 $output_storage_file`;
	if [[ "$commandHistoryEntry" == ":1" ]]; then
	    navigationInput=`head -1 $input_storage_file`;
	    forwardUserInput=true;
	elif [[ "$commandHistoryEntry" != ":2" ]] && [[ "$commandHistoryEntry" != ":3" ]] && [[ "$commandHistoryEntry" != ":4" ]]; then
	    if [[ "$1" == "--execute" ]]; then
		# execute the actual command from command history menu
		commandToExecute="$commandHistoryEntry";
		prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
		"$pythonPath" "$scriptDir"/execute_new_command.py "$commandToExecute";
		commandResult=`head -1 $output_storage_file`;
	    else
		# edit the chosen command prior to executing
		"$pythonPath" "$scriptDir"/edit_and_exec_prev_command.py "$commandHistoryEntry";
		if [[ $? == 0 ]]; then
		    prevCommand=`head -1 $input_storage_file`;
		    commandResult=`head -1 $output_storage_file`;
		fi
	    fi
	fi
    }
    # helper function that handles all possible options entered by user in navigation mode
    function handleNavigationOption {
	case $navigationInput in
	'?')
	    "$pythonPath" "$scriptDir"/display_help.py;
	    ;;
	':-')
	    if [[ -z $prevCommand ]]; then
		echo 'No shell command previously executed';
	    else
		"$pythonPath" "$scriptDir"/execute_new_command.py "$prevCommand";
		commandResult=`head -1 $output_storage_file`;
	    fi
	    ;;
	':')
	    "$pythonPath" "$scriptDir"/edit_and_exec_prev_command.py "$prevCommand";
	    if [[ $? == 0 ]]; then
		prevCommand=`head -1 $input_storage_file`;
		commandResult=`head -1 $output_storage_file`;
	    fi
	    ;;
	':<')
	    goToCommandMenu --execute;
	    ;;
	'::')
	    goToCommandMenu --edit;
	    ;;
	':<>')
	    "$pythonPath" "$scriptDir"/clear_command_history.py;
	    ;;
	'<'*)
	    secondArg=${navigationInput:1};
	    goToMenu -h "$secondArg";
	    ;;
	'>'*)
	    secondArg=${navigationInput:1};
	    goToMenu -f "$secondArg";
	    ;;
	',')
	    "$pythonPath" "$scriptDir"/go_to_dir.py "$prevDir";
	    prevDir=`head -1 $output_storage_file`;
	    cd "`head -1 $input_storage_file`";
	    ;;
	'+>')
	    "$pythonPath" "$scriptDir"/add_dir_to_favorites.py
	    ;;
	'->')
	    "$pythonPath" "$scriptDir"/remove_dir_from_favorites.py;
	    if [[ $? == 2 ]]; then
		# handle the input as "normal" navigation input
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    ;;
	'!<>')
	    "$pythonPath" "$scriptDir"/clear_history.py;
	    ;;
	'!')
	    return 0;
	    ;;
	*)
	    # handle general input (the above cases are "special input")
	    if [[ ${navigationInput:0:1} == ':' ]]; then # A string starting with ':' will be treated as a command (alternative way of entering new commands from navigation mode)
		commandToExecute=${navigationInput:1};
		prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
		"$pythonPath" "$scriptDir"/execute_new_command.py "$commandToExecute";
		commandResult=`head -1 $output_storage_file`;
	    else
	        if [[ -z $navigationInput ]]; then
		    "$pythonPath" "$scriptDir"/go_to_dir.py;
		else
		    "$pythonPath" "$scriptDir"/go_to_dir.py "$navigationInput" "$prevDir";
		fi
		prevDir=`head -1 $output_storage_file`;
		cd "`head -1 $input_storage_file`";
	    fi
	    ;;
	esac
    }
    # stores last executed shell command (if any) and its result
    prevCommand='';
    commandResult='';
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	if [[ $navigationInput != "?" ]]; then
	    if [[ -z $prevCommand ]]; then
		"$pythonPath" "$scriptDir"/display_general_navigation_output.py;
	    else
		"$pythonPath" "$scriptDir"/display_general_navigation_output.py "$prevCommand" "$commandResult";
	    fi
	fi
	read -e navigationInput;
	# stay in this loop as long as the function called by choosing a navigation option forwards user input back to the navigate function
	while [[ '1' == '1' ]]; do
	    clear;
	    handleNavigationOption;
	    if [[ $forwardUserInput == true ]]; then
		forwardUserInput=false;
	    else
		break;
	    fi
	done
	if [[ $navigationInput == '!' ]]; then
	    echo 'You exited navigation mode.';
	    unset -f goToCommandMenu;
	    unset -f handleNavigationOption;
	    return 0;
	fi
    done
}

# Disable all "private" functions so they cannot be accessed by user from CLI
unset -f goToCommandMenu;
unset -f handleNavigationOption;
