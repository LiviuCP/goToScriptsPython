# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by choosing the entry number
# - adding directories to favorites menu and enabling jumping to one of these by just choosing the entry number

scriptDir=~; #get script directory in order to build the paths of the supporting files
prevDir=''; #this variable is used both by the goto function and the function that jumps to previous directory
#
input_storage_file=$scriptDir/.store_input; # temporary solution for getting the user input from the python scripts connected to .functions_goto
output_storage_file=$scriptDir/.store_output; # temporary solution for getting the python script output connected to .functions_goto
#
forwardUserInput=false; #variable used in navigation mode to determine if the user input received by a called function should be processed after function exits
editPrevCommand=false; #variable used for determinining if an entry from command history is fed to the user for editing so a new command is executed based on previous input
#
pythonPath='/usr/bin/python3'

# initialize the environment, ensure the navigation and command history menus are sorted/consolidated
"$pythonPath" "$scriptDir"/.init.py
"$pythonPath" "$scriptDir"/.consolidate_history.py
"$pythonPath" "$scriptDir"/.consolidate_command_history.py
#
# This function is used for navigating to a new directory; if cd is successful the visited path is memorized into navigation history
function goToDir {
    #
    # Step 1: if an argument was entered check that the argument is valid (entered path exists and is a directory);
    if [[ ! -z $1 ]] && [[ ! -d $1 ]]; then
	if [[ -e $1 ]]; then
	    echo "$1 is not a directory.";
	    return 1;
	fi
	echo "Invalid directory $1";
	echo 'Either is the name invalid (please check spelling) or the directory has been deleted.';
	return 1;  
    fi
    #
    # Step 2: memorize current directory and cd to the new directory (if no argument had been entered, cd to the user home directory)
    prevDir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
    if [[ -z $1 ]]; then
	cd ~ ;
    else
	cd "$1";
    fi
    #
    # Step 3: check if the cd operation has been successful
    if [[ $? != 0 ]]; then 
	echo 'Cannot change directory, the cd command returned an error.';
	echo 'Please try again.';
	return 1;  
    fi
    #
    # Step 4: if cd was done to a different directory than the previous one, update the individual history files and then consolidate recent and persistent history
    currentDir=`pwd`;
    clear;
    echo "Previous directory: $prevDir";
    echo "Opened directory: $currentDir";
    if [[ $currentDir == $prevDir ]]; then
	return 0;
    fi
    "$pythonPath" "$scriptDir"/.update_individual_history_files.py "$currentDir"
    "$pythonPath" "$scriptDir"/.consolidate_history.py
}

# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
function goToMenu {
    # handles the case when the directory chosen for visiting does not exist
    function handleMissingDirectory {
	clear;
	echo "Invalid path $dirPath";
	echo 'The directory might have been moved or deleted.';
	echo;
	echo 'Please choose the required action: ';
	echo '!r to remove the directory from the menus';
	echo '!m to map to an existing directory';
	echo '! to quit';
	echo;
	read -e userChoice;
	# user chooses to remove the entry from menus (consolidated history and/or favorites)
	if [[ $userChoice == '!r' ]]; then
	    "$pythonPath" "$scriptDir"/.remove_missing_dir.py "$dirPath"
	# user chooses to replace the directory entry with another (existing) path
	elif [[ $userChoice == '!m' ]]; then
	    clear;
	    echo "Missing directory: $dirPath";
	    echo;
	    echo 'Enter the name of the replacing directory: ';
	    read -e replacingDir;
	    # the mapping directory should exist and be a valid directory
	    if [[ ! -d "$replacingDir" ]]; then
		echo;
		echo "Directory $replacingDir does not exist or has been deleted.";
		echo;
		echo "Mapping failed.";
		return 1;
	    fi
	    # ensure the absolute path of the replacing directory is obtained (we need it to grep into the files)
	    cd "$replacingDir";
	    replacingDir=`pwd`;
	    cd - > /dev/null;
	    # do the actual mapping in the files
	    "$pythonPath" "$scriptDir"/.map_missing_dir.py "$dirPath" "$replacingDir"
	elif [[ $userChoice == '!' ]]; then
	    clear;
	    echo "You exited the $menuType menu.";
	else
	    # handle the input as "normal" navigation input
	    navigationInput="$userChoice";
	    forwardUserInput=true;
	fi
    }

    # Step 1: provide input for choosing a path from history/favorites
    if [[ -z "$2" ]]; then
	"$pythonPath" "$scriptDir"/.choose_path_from_menu.py "$1";
    else
	"$pythonPath" "$scriptDir"/.choose_path_from_menu.py "$1" "$2";
    fi

    # Step 2: handle python script output (navigate only if a valid and existing path has been chosen)
    dirPath=`head -1 $output_storage_file`;
    if [[ "$dirPath" == ":1" ]]; then
	navigationInput=`head -1 $input_storage_file`;
	forwardUserInput=true;
    elif [[ "$dirPath" != ":2" ]] && [[ "$dirPath" != ":3" ]] && [[ "$dirPath" != ":4" ]]; then
	if [[ ! -d "$dirPath" ]]; then
	    handleMissingDirectory;
	    unset -f handleMissingDirectory;
	    return 1;
	fi
	goToDir "$dirPath";
    fi
}

# used for returning to the previously visited directory without needing to access the history or favorites menus
function goToPrevDir {
    if [[ $prevDir == '' ]]; then
	echo 'Cannot jump to previous directory.';
	echo 'No directory visited in the current session.';
	return 1;
    fi
    goToDir "$prevDir";
}

# used for adding a directory (either the current one or another) to favorites
function addToFavorites {
    #
    # Step 1: check if the user entered an argument or not
    # - the argument is a relative/absolute path of a directory that should be added to the favorite dirs (if it exists)
    # - if no argument was entered, the current directory will be added to favorites
    if [[ ! -z "$1" ]]; then
	if [[ ! -d "$1" ]]; then
	    echo "Directory $1 does not exist or has been deleted.";
	    echo 'Cannot add to favorites.';
	    return 1;
	fi
	cd "$1";
	dirToAdd=`pwd`;
	cd - > /dev/null;
    else
	dirToAdd=`pwd`;
    fi
    #
    # Step 2: append the path to the favorites file (create it if it does not exist)
    #
    "$pythonPath" "$scriptDir"/.add_dir_to_favorites.py "$dirToAdd";
}

# this function removes the entry from favorites and moves it back to persistent history
function removeFromFavorites {
    "$pythonPath" "$scriptDir"/.remove_dir_from_favorites.py;
    exit_code=$?;
    if [[ $exit_code == 1 || $exit_code == 0 ]]; then
	return $exit_code;
    elif [[ $exit_code == 2 ]]; then
	# handle the input as "normal" navigation input
	navigationInput=`head -1 $input_storage_file`;
	forwardUserInput=true;
	return 0;
    fi
}

# This function is used to enter navigation mode
# In this mode the user can repeatedly visit directories by only entering the name of each folder (absolute path, relative path - including wildcards)
# It is also possible to access other functions like history/favorites, goto previous directory etc.
function navigate {
    # accesses the menu with the most recent executed commands, user can choose one entry to execute that command again
    function goToCommandMenu {
	# Step 1: handle user input
	if [[ $editPrevCommand == false ]]; then
	    "$pythonPath" "$scriptDir"/.choose_command_from_menu.py --execute
	else
	    "$pythonPath" "$scriptDir"/.choose_command_from_menu.py --edit
	fi

	# Step 2: handle python script output (handle command edit/execution only if a valid command has been chosen from menu file)
	commandHistoryEntry=`head -1 $output_storage_file`;
	if [[ "$commandHistoryEntry" == ":1" ]]; then
	    navigationInput=`head -1 $input_storage_file`;
	    forwardUserInput=true;
	elif [[ "$commandHistoryEntry" != ":2" ]] && [[ "$commandHistoryEntry" != ":3" ]] && [[ "$commandHistoryEntry" != ":4" ]]; then
	    if [[ $editPrevCommand == false ]]; then
		# execute the actual command from command history menu
		commandToExecute="$commandHistoryEntry";
		prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
		"$pythonPath" "$scriptDir"/.execute_new_command.py "$commandToExecute";
		commandResult=`head -1 $output_storage_file`;
	    else
		# edit the chosen command prior to executing
		editAndExecCmdFromHistory;
	    fi
	fi
    }
    # helper function for executing previous shell command again
    function repeatPrevCommand {
	if [[ -z $prevCommand ]]; then
	    echo 'No shell command previously executed';
	else
	    "$pythonPath" "$scriptDir"/.execute_new_command.py "$prevCommand";
	    commandResult=`head -1 $output_storage_file`;
	fi
    }
    # helper function that feeds a previously executed command (from command history) to user for editing prior to having it executed
    function editAndExecCmdFromHistory {
	echo 'Please edit the below command and hit ENTER to execute';
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$commandHistoryEntry" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
	    "$pythonPath" "$scriptDir"/.execute_new_command.py "$commandToExecute";
	    commandResult=`head -1 $output_storage_file`;
	fi
    }
    # helper function for handling general input (new commands or directories to navigate to)
    function handleGeneralInput {
	# A string starting with ':' will be treated as a command (alternative way of entering new commands from navigation mode)
	if [[ ${navigationInput:0:1} == ':' ]]; then
	    commandToExecute=${navigationInput:1};
	    prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
	    "$pythonPath" "$scriptDir"/.execute_new_command.py "$commandToExecute";
	    commandResult=`head -1 $output_storage_file`;
	else
	    goToDir `echo "$navigationInput"`;
	fi
    }
    # helper function for executing a new command based on the string of the previously executed shell command
    function execCommandBasedOnPrevInput {
	if [[ -z "$prevCommand" ]]; then
	    echo 'No shell command previously executed. Enter a new command';
	else
	    echo 'Please edit the below command and hit ENTER to execute';
	fi
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$prevCommand" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
	    "$pythonPath" "$scriptDir"/.execute_new_command.py "$commandToExecute";
	    commandResult=`head -1 $output_storage_file`;
	fi
    }
    # helper function that handles all possible options entered by user in navigation mode
    function handleNavigationOption {
	case $navigationInput in
	'?')
	    "$pythonPath" "$scriptDir"/.display_help.py;
	    ;;
	':-')
	    repeatPrevCommand;
	    ;;
	':')
	    execCommandBasedOnPrevInput;
	    ;;
	':<')
	    editPrevCommand=false;
	    goToCommandMenu;
	    ;;
	'::')
	    editPrevCommand=true;
	    goToCommandMenu;
	    ;;
	':<>')
	    "$pythonPath" "$scriptDir"/.clear_command_history.py;
	    ;;
	'<'*)
	    secondArg=${navigationInput:1};
	    goToMenu -h "$secondArg";
	    ;;
	'>'*)
	    secondArg=${navigationInput:1};
	    goToMenu -f "$secondArg";
	    ;;
	',')
	    goToPrevDir;
	    ;;
	'+>')
	    addToFavorites;
	    ;;
	'->')
	    removeFromFavorites;
	    ;;
	'!<>')
	    "$pythonPath" "$scriptDir"/.clear_history.py;
	    ;;
	'!')
	    return 0;
	    ;;
	*)
	    handleGeneralInput;
	    ;;
	esac
    }
    # stores last executed shell command (if any) and its result
    prevCommand='';
    commandResult='';
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	if [[ $navigationInput != "?" ]]; then
	    if [[ -z $prevCommand ]]; then
		"$pythonPath" "$scriptDir"/.display_general_navigation_output.py;
	    else
		"$pythonPath" "$scriptDir"/.display_general_navigation_output.py "$prevCommand" "$commandResult";
	    fi
	fi
	read -e navigationInput;
	# stay in this loop as long as the function called by choosing a navigation option forwards user input back to the navigate function
	while [[ '1' == '1' ]]; do
	    clear;
	    handleNavigationOption;
	    if [[ $forwardUserInput == true ]]; then
		forwardUserInput=false;
	    else
		break;
	    fi
	done
	if [[ $navigationInput == '!' ]]; then
	    echo 'You exited navigation mode.';
	    unset -f goToCommandMenu;
	    unset -f repeatPrevCommand;
	    unset -f editAndExecCmdFromHistory;
	    unset -f handleGeneralInput;
	    unset -f execCommandBasedOnPrevInput;
	    unset -f handleNavigationOption;
	    return 0;
	fi
    done
}
#
# Disable all "private" functions so they cannot be accessed by user from CLI
unset -f handleMissingDirectory;
unset -f goToCommandMenu;
unset -f repeatPrevCommand;
unset -f editAndExecCmdFromHistory;
unset -f execCommandBasedOnPrevInput;
unset -f handleGeneralInput;
unset -f handleNavigationOption;
