# This file contains functions used for: navigating between folders, tracking history of navigated folders, adding dirs to favorites menu, etc.
scriptDir=~; #get script directory in order to build the paths of the supporting files
prevDir=`pwd`; #this variable is used by the function that jumps to previous directory (default is the current directory from which the script launches)
input_storage_file=$scriptDir/.store_input; # temporary solution for getting the user input from the python scripts connected to .functions_goto
output_storage_file=$scriptDir/.store_output; # temporary solution for getting the python script output connected to .functions_goto
forwardUserInput=false; #variable used in navigation mode to determine if the user input received by a called function should be processed after function exits
pythonPath='/usr/bin/python3'

# initialize the environment, ensure the navigation and command history menus are sorted/consolidated
"$pythonPath" "$scriptDir"/init.py

# This function is used to enter the directory navigation console (no cd required but only the dir name including wildcards; for commands use ':')
function navigate {
    # helper function that handles all possible options entered by user in navigation mode
    function handleNavigationOption {
	case $navigationInput in
	'?')
	    "$pythonPath" "$scriptDir"/display_help.py;
	    ;;
	':-')
	    if [[ -z $prevCommand ]]; then
		echo 'No shell command previously executed';
	    else
		"$pythonPath" "$scriptDir"/execute_new_command.py "$prevCommand";
		commandResult=`head -1 $output_storage_file`;
	    fi
	    ;;
	':')
	    "$pythonPath" "$scriptDir"/wrapper_edit_and_exec_prev_command.py "$prevCommand";
	    if [[ $? == 0 ]]; then
		prevCommand=`head -1 $input_storage_file`;
		commandResult=`head -1 $output_storage_file`;
	    fi
	    ;;
	':<')
	    "$pythonPath" "$scriptDir"/go_to_command_menu.py "--execute";
	    result=$?;
	    if [[ $result == 0 ]]; then
		prevCommand=`head -1 $input_storage_file`;
		commandResult=`head -1 $output_storage_file`;
	    elif [[ $result == 1 ]]; then
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    ;;
	'::')
	    "$pythonPath" "$scriptDir"/go_to_command_menu.py "--edit";
	    result=$?;
	    if [[ $result == 0 ]]; then
		prevCommand=`head -1 $input_storage_file`;
		commandResult=`head -1 $output_storage_file`;
	    elif [[ $result == 1 ]]; then
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    ;;
	':<>')
	    "$pythonPath" "$scriptDir"/clear_command_history.py;
	    ;;
	'<'*)
	    navInput=${navigationInput:1};
	    "$pythonPath" "$scriptDir"/go_to_menu.py "-h" "$prevDir" "$navInput";
	    result=$?;
	    if [[ $result == 0 ]]; then
		prevDir=`head -1 $output_storage_file`;
		cd "`head -1 $input_storage_file`";
	    elif [[ $result == 1 ]]; then
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    ;;
	'>'*)
	    navInput=${navigationInput:1};
	    "$pythonPath" "$scriptDir"/go_to_menu.py "-f" "$prevDir" "$navInput";
	    result=$?;
	    if [[ $result == 0 ]]; then
		prevDir=`head -1 $output_storage_file`;
		cd "`head -1 $input_storage_file`";
	    elif [[ $result == 1 ]]; then
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    ;;
	',')
	    "$pythonPath" "$scriptDir"/wrapper_go_to_dir.py "$prevDir" "`pwd`";
	    prevDir=`head -1 $output_storage_file`;
	    cd "`head -1 $input_storage_file`";
	    ;;
	'+>')
	    "$pythonPath" "$scriptDir"/add_dir_to_favorites.py
	    ;;
	'->')
	    "$pythonPath" "$scriptDir"/remove_dir_from_favorites.py;
	    if [[ $? == 2 ]]; then
		# handle the input as "normal" navigation input
		navigationInput=`head -1 $input_storage_file`;
		forwardUserInput=true;
	    fi
	    ;;
	'!<>')
	    "$pythonPath" "$scriptDir"/clear_history.py;
	    ;;
	'!')
	    return 0;
	    ;;
	*)
	    # handle general input (the above cases are "special input")
	    if [[ ${navigationInput:0:1} == ':' ]]; then # A string starting with ':' will be treated as a command (alternative way of entering new commands from navigation mode)
		commandToExecute=${navigationInput:1};
		prevCommand="$commandToExecute"; # memorize the command in a separate variable for later usage
		"$pythonPath" "$scriptDir"/execute_new_command.py "$commandToExecute";
		commandResult=`head -1 $output_storage_file`;
	    else
	        if [[ -z $navigationInput ]]; then
		    "$pythonPath" "$scriptDir"/wrapper_go_to_dir.py;
		else
		    "$pythonPath" "$scriptDir"/wrapper_go_to_dir.py "$navigationInput" "$prevDir";
		fi
		prevDir=`head -1 $output_storage_file`;
		cd "`head -1 $input_storage_file`";
	    fi
	    ;;
	esac
    }
    # stores last executed shell command (if any) and its result
    prevCommand='';
    commandResult='';
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	if [[ $navigationInput != "?" ]]; then
	    if [[ -z $prevCommand ]]; then
		"$pythonPath" "$scriptDir"/display_general_navigation_output.py;
	    else
		"$pythonPath" "$scriptDir"/display_general_navigation_output.py "$prevCommand" "$commandResult";
	    fi
	fi
	read -e navigationInput;
	# stay in this loop as long as the function called by choosing a navigation option forwards user input back to the navigate function
	while [[ '1' == '1' ]]; do
	    clear;
	    handleNavigationOption;
	    if [[ $forwardUserInput == true ]]; then
		forwardUserInput=false;
	    else
		break;
	    fi
	done
	if [[ $navigationInput == '!' ]]; then
	    echo 'You exited navigation mode.';
	    unset -f handleNavigationOption;
	    return 0;
	fi
    done
}

# Disable all "private" functions so they cannot be accessed by user from CLI
unset -f handleNavigationOption;
