# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by choosing the entry number
# - adding directories to favorites menu and enabling jumping to one of these by just choosing the entry number
#
# GLOBAL VARIABLES
#
scriptDir=~; #get script directory in order to build the paths of the supporting files
prevDir=''; #this variable is used both by the goto function and the function that jumps to previous directory
logDir=$scriptDir/.goToLogs; #in this directory the script stores the "log" files which contain the paths of the visited directories for each day
#
r_hist_file=$scriptDir/.recent_history; #file containing a list of the most recently visited directories
p_hist_file=$scriptDir/.persistent_history; #file containing each visited directory and the number of visits (used for determining the most visited directories, which will be copied in the consolidated history file)
e_hist_file=$scriptDir/.excluded_history; #file containing the entries excluded from the persistent history file due to the fact that they had been added to favorites
c_r_hist_file=$scriptDir/.recent_command_history; #file containing the last commands executed by user in navigation mode (unsorted)
#
hist_file=$scriptDir/.goto_history; #file containing the consolidated directory access history (most recently and most frequently visited dirs)
fav_file=$scriptDir/.goto_favorites; #file containing the directories saved to favorites
format_file=$scriptDir/.goto_format; #file used for formatting output (either the content of the favorites file or the content of the consolidated history file)
c_hist_file=$scriptDir/.command_history; #file containing the last commands executed by user in navigation mode (sorted)
temp_file=$scriptDir/.temp; #temporary file used for various operations (to be removed each time the operation it is used in finishes)
aux_temp_file=$scriptDir/.aux_temp; #auxiliary temporary file (in case the first temp file is not enough)
input_storage_file=$scriptDir/.store_input; # temporary solution for getting the user input from the python scripts connected to .functions_goto
#
rHistMaxRows=10; #maximum number of entries allowed in the recent history file
pHistMaxRows=15; #maximum number of entries allowed in the persistent history file
cHistMaxRows=25; #maximum number of entries allowed in the command history file
maxNrOfItems=50; #maximum number of files/dirs listed from current directory in navigation mode
maxNrOfChars=25; #maximum number of characters to be displayed for each item from current directory in navigation mode
minNrOfCmdChars=10; #minimum number of characters (including spaces) that a command should have to be included in command history
forwardUserInput=false; #variable used in navigation mode to determine if the user input received by a called function should be processed after function exits
editPrevCommand=false; #variable used for determinining if an entry from command history is fed to the user for editing so a new command is executed based on previous input
#
nonNegativeInteger='^[0-9]+$'; #regex used to test if the input is a non-negative number
pythonPath='/usr/bin/python3'
#
# GLOBAL FUNCTIONS
#
# initialize the environment
"$pythonPath" "$scriptDir"/.init.py
# consolidate history (in case the user just modified the number of entries allowed in recent and persistent history)
"$pythonPath" "$scriptDir"/.consolidate_history.py
# ensure the command history is sorted
"$pythonPath" "$scriptDir"/.consolidate_command_history.py
#
# This function is used for navigating to a new directory by using a cd command
# It also memorizes the visited directories in history files
# The argument can be a relative or an absolute path
# The function returns value 0 for successful execution and 1 in any other situation
#
function goToDir {
    #
    # Step 1: if an argument was entered check that the argument is valid (entered path exists and is a directory);
    if [[ ! -z $1 ]] && [[ ! -d $1 ]]; then
	if [[ -e $1 ]]; then
	    echo "$1 is not a directory.";
	    return 1;
	fi
	echo "Invalid directory $1";
	echo 'Either is the name invalid (please check spelling) or the directory has been deleted.';
	return 1;  
    fi
    #
    # Step 2: memorize current directory and cd to the new directory (if no argument had been entered, cd to the user home directory)
    prevDir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
    if [[ -z $1 ]]; then
	cd ~ ;
    else
	cd "$1";
    fi
    #
    # Step 3: check if the cd operation has been successful
    if [[ $? != 0 ]]; then 
	echo 'Cannot change directory, the cd command returned an error.';
	echo 'Please try again.';
	return 1;  
    fi
    #
    # Step 4: if cd was done to a different directory than the previous one, update the individual history files and then consolidate recent and persistent history
    currentDir=`pwd`;
    clear;
    echo "Previous directory: $prevDir";
    echo "Opened directory: $currentDir";
    if [[ $currentDir == $prevDir ]]; then
	return 0;
    fi
    "$pythonPath" "$scriptDir"/.update_individual_history_files.py "$currentDir"
    "$pythonPath" "$scriptDir"/.consolidate_history.py
}
#
# ******************************************************************************************************************
#
# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
function goToMenu {
    # Helper functions for display
    #
    # formats the content of the consolidated history file or the favorites file; output is written into a file that is used by one of the display functions listed below
    function formatFileContent {
	input_file=$1;
	> "$format_file";
	while read currentEntry;
	do
	    currentEntryFormatted=`basename "$currentEntry"`':     '"$currentEntry";
	    echo "$currentEntryFormatted" >> "$format_file";
	done < "$input_file"
	column -t -s ':' "$format_file" > "$temp_file";
	mv "$temp_file" "$format_file";
    }
    #displays the consolidated history menu in a convenient manner for the user
    function displayHistory {
	tempVar1=`wc -l "$r_hist_file"`;
	tempVar2=`wc -l "$hist_file"`;
	rHistEntries=`echo $tempVar1 | cut -f 1 -d ' '`;
	histEntries=`echo $tempVar2 | cut -f 1 -d ' '`;
	let pHistEntries=histEntries-rHistEntries;
	formatFileContent "$hist_file";
	clear;
	echo 'NAVIGATION HISTORY';
	echo;
	echo '-- RECENTLY VISITED DIRECTORIES --';
	echo;
	cat -n "$format_file" | head -"$rHistEntries";
	echo;
	echo '--   MOST VISITED DIRECTORIES   --';
	echo;
	cat -n "$format_file" | tail -"$pHistEntries";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	echo 'Enter ! to quit.';
	echo;
    }
    #displays the favorites menu in a different (tailor-made) manner from the history menu
    function displayFavorites {
	formatFileContent "$fav_file";
	clear;
	echo 'FAVORITE DIRECTORIES';
	echo;
	cat -n "$format_file";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	echo 'Enter ! to quit.';
	echo;
    }
    # handles the case when the directory chosen for visiting does not exist
    function handleMissingDirectory {
	# working log file for the current day also needs update (if existing and if the entry is present)
	w_log_file="$logDir"/`date +"%Y%m%d"`;
	clear;
	echo "Invalid path $dirPath";
	echo 'The directory might have been moved or deleted.';
	echo;
	echo 'Please choose the required action: ';
	echo '!r to remove the directory from the menus';
	echo '!m to map to an existing directory';
	echo '! to quit';
	echo;
	read -e userChoice;
	# user chooses to remove the entry from menus (consolidated history and/or favorites)
	if [[ $userChoice == '!r' ]]; then
	    # ensure the entry gets removed from the working log file (if the file had been created in the current day)
	    if [[ -f "$w_log_file" ]]; then
		grep -xv "$dirPath" "$w_log_file" > "$temp_file";
		mv "$temp_file" "$w_log_file";
	    fi
	    # ensure the entry is removed from recent history (if there)
	    grep -xv "$dirPath" "$r_hist_file" > "$temp_file";
	    mv "$temp_file" "$r_hist_file";
	    # ensure the entry is removed from persistent history (if there)
	    grep -v "$dirPath"';' "$p_hist_file" > "$temp_file";
	    sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
	    rm "$temp_file";
	    # ensure the entry is removed from favorites file (if there)
	    grep -v "$dirPath"';' "$e_hist_file" > "$temp_file";
	    mv "$temp_file" "$e_hist_file";
	    grep -xv "$dirPath" "$fav_file" > "$temp_file";
	    mv "$temp_file" "$fav_file";
	    # history should be consolidated again
	    "$pythonPath" "$scriptDir"/.consolidate_history.py;
	    # confirm removal has been successfully performed
	    echo;
	    echo "Entry $dirPath has been removed from the menus.";
	# user chooses to replace the directory entry with another (existing) path
	elif [[ $userChoice == '!m' ]]; then
	    clear;
	    echo "Missing directory: $dirPath";
	    echo;
	    echo 'Enter the name of the replacing directory: ';
	    read -e replacingDir;
	    # the mapping directory should exist and be a valid directory
	    if [[ ! -d "$replacingDir" ]]; then
		echo;
		echo "Directory $replacingDir does not exist or has been deleted.";
		echo;
		echo "Mapping failed.";
		return 1;
	    fi
	    # ensure the entry gets removed from the working log file (if the file had been created in the current day)
	    if [[ -f "$w_log_file" ]]; then
		grep -xv "$dirPath" "$w_log_file" > "$temp_file";
		mv "$temp_file" "$w_log_file";
	    fi
	    # ensure the absolute path of the replacing directory is obtained (we need it to grep into the files)
	    cd "$replacingDir";
	    replacingDir=`pwd`;
	    cd - > /dev/null;
	    # identify the file where the path of the directory to be replaced lives
	    grep "$dirPath"';' "$e_hist_file" > /dev/null;
	    if [[ $? == 0 ]]; then
		replaced_dir_file="$e_hist_file";
	    else
		replaced_dir_file="$p_hist_file";
	    fi
	    # check if the replacing dir is part of consolidated history, favorites file or none of them (not yet visited or added to favorites)
	    visits_file=''; # the file where the number of visits of the replacing directory will be looked for (no file if not yet visited or added to favorites)
	    foundEntry=`grep "$replacingDir"';' "$p_hist_file"`;
	    if [[ $? == 0 ]]; then
		visits_file="$p_hist_file";
	    else
		foundEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		if [[ $? == 0 ]]; then
		    visits_file="$e_hist_file";
		fi
	    fi
	    # get number of times the replacing directory has been visited (-1 if not visited/not added to favorites)
	    if [[ "$visits_file" == "$p_hist_file" ]]; then
		replacingDirEntry=`grep "$replacingDir"';' "$p_hist_file"`;
		replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
	    elif [[ "$visits_file" == "$e_hist_file" ]]; then
		replacingDirEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
	    else
		replacingDirVisits='-1';
	    fi
	    # remove the entry from recent history (if there)
	    grep -xv "$dirPath" "$r_hist_file" > "$temp_file";
	    mv "$temp_file" "$r_hist_file";
	    # do the actual mapping operation
	    replacedDirMatchedRow=`grep "$dirPath"';' "$replaced_dir_file"`;
	    replacedDirVisits=`echo $replacedDirMatchedRow | cut -f 2 -d ';'`;
	    # - case 1: the replacing directory is not contained in the files (not yet visited/not yet added to favorites) - just do a path replacement
	    if [[ $replacingDirVisits == '-1' ]]; then
		replacedDirReplacingRow="$replacingDir"';'"$replacedDirVisits";
		grep -v "$replacedDirMatchedRow" "$replaced_dir_file" > "$temp_file";
		echo "$replacedDirReplacingRow" >> "$temp_file";
		mv "$temp_file" "$replaced_dir_file";
		# if missing dir had been in the persistent history file: re-sort file
		if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
		    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
		    mv "$temp_file" "$p_hist_file";
		# if missing dir had been in the excluded history file: re-create favorites file after update (and re-sort)
		else
		    cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		    "$pythonPath" "$scriptDir"/.sort_favorites_by_basename.py
		fi
	    # - case 2: the replacing directory is contained either in the persistent history file or in the favorites file
	    else
		# if the number of visits of the dir to be replaced exceeds the one of the replacing dir, then update the number of visits of the replacing dir to the higher figure
		if [[ $replacingDirVisits -lt $replacedDirVisits ]]; then
		    replacingDirPath=`echo $replacingDirEntry | cut -f 1 -d ';'`;
		    replacingDirReplacingRow="$replacingDirPath"';'"$replacedDirVisits";
		    grep -v "$replacingDirEntry" "$visits_file" > "$temp_file";
		    echo "$replacingDirReplacingRow" >> "$temp_file";
		    mv "$temp_file" "$visits_file";
		fi
		# remove the replaced directory from its file (either persistent history or excluded history file)
		grep -v "$dirPath"';' "$replaced_dir_file" > "$temp_file";
		mv "$temp_file" "$replaced_dir_file";
		# if missing dir had been in the persistent history file: re-sort file
		if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
		    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
		    mv "$temp_file" "$p_hist_file";
		# if missing dir had been in the excluded history file: re-create favorites file after update (and re-sort)
		else
		    cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		    "$pythonPath" "$scriptDir"/.sort_favorites_by_basename.py;
		fi
	    fi
	    # history should be consolidated again
	    "$pythonPath" "$scriptDir"/.consolidate_history.py;
	    # confirm mapping has been successfully performed
	    echo;
	    echo "Missing directory replaced with: $replacingDir";
	    echo;
	    echo 'Mapping performed successfully.';
	elif [[ $userChoice == '!' ]]; then
	    clear;
	    echo "You exited the $menuType menu.";
	else
	    # handle the input as "normal" navigation input
	    navigationInput="$userChoice";
	    forwardUserInput=true;
	fi
    }
    # unsets all helper functions so they are not accessible by user from CLI
    # should be called before the main function returns, otherwise the helpers might become inaccessible earlier than required
    # the unsetHelpers function should be itself unset (right after it runs)
    function unsetHelpers {
	unset -f formatFileContent;
	unset -f displayHistory;
	unset -f displayFavorites;
	unset -f handleMissingDirectory;
    }
    #
    # Step 0: choose the file to be used for navigating, check if it is empty, (if not) display it and prompt the user to enter the number of the entry that contains the path the user wants to navigate to
    if [[ "$1" == '-f' ]]; then
	input_file="$fav_file";
	display='displayFavorites';
	menuType='favorites';
    elif [[ "$1" == '-h' ]]; then
	input_file="$hist_file";
	display='displayHistory';
	menuType='history';
    else
	echo 'Invalid first argument of the goToMenu function.';
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    #
    if [[ ! -s "$input_file" ]]; then
	echo "There are no entries in the $menuType menu.";
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    # display menu only if user hasn't given the entry explicitly in the command
    if [[ -z "$2" ]]; then
	eval "$display";
	read -e dirNr;
    else
	dirNr=$2;
    fi
    #
    # Step 1: handle the user input
    tempVar=`wc -l "$input_file"`;
    currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
    # 1a: user entered the number of an entry from the history/favorites file
    if [[ $dirNr =~  $nonNegativeInteger     ]] &&
       [[ $dirNr -ge 1                       ]] &&
       [[ $dirNr -le $currentNumberOfEntries ]]; then
	# read the line from the input file
	dirPath=`sed "$dirNr"'q;d' "$input_file"`;
	# if the line of the input file contains a valid directory path, then visit the directory
	if [[ ! -d "$dirPath" ]]; then
	    handleMissingDirectory;
	    unsetHelpers 2> /dev/null;
	    unset -f unsetHelpers;
	    return 1;
	fi
	goToDir "$dirPath";
    # 1b: user chose to quit the function
    elif [[ $dirNr == '!' ]]; then
	clear;
	echo "You exited the $menuType menu.";
    # 1c: any other input to be passed further to the navigate function (if goToMenu had been called from navigation mode)
    else
	navigationInput="$dirNr";
	forwardUserInput=true;
	return 0;
    fi
    #
    unsetHelpers 2> /dev/null;
    unset -f unsetHelpers;
}
#
# ******************************************************************************************************************
#
# used for returning to the previously visited directory without needing to access the history or favorites menus
function goToPrevDir {
    if [[ $prevDir == '' ]]; then
	echo 'Cannot jump to previous directory.';
	echo 'No directory visited in the current session.';
	return 1;
    fi
    goToDir "$prevDir";
}
#
# ******************************************************************************************************************
#
# used for adding a directory (either the current one or another) to favorites
function addToFavorites {
    #
    # Step 1: check if the user entered an argument or not
    # - the argument is a relative/absolute path of a directory that should be added to the favorite dirs (if it exists)
    # - if no argument was entered, the current directory will be added to favorites
    if [[ ! -z "$1" ]]; then
	if [[ ! -d "$1" ]]; then
	    echo "Directory $1 does not exist or has been deleted.";
	    echo 'Cannot add to favorites.';
	    return 1;
	fi
	cd "$1";
	dirToAdd=`pwd`;
	cd - > /dev/null;
    else
	dirToAdd=`pwd`;
    fi
    #
    # Step 2: append the path to the favorites file (create it if it does not exist)
    #
    "$pythonPath" "$scriptDir"/.add_dir_to_favorites.py "$dirToAdd";
}
#
# ******************************************************************************************************************
#
# this function removes the entry from favorites and moves it back to persistent history
function removeFromFavorites {
    "$pythonPath" "$scriptDir"/.remove_dir_from_favorites.py;
    exit_code=$?;
    if [[ $exit_code == 1 || $exit_code == 0 ]]; then
	return $exit_code;
    elif [[ $exit_code == 2 ]]; then
	# handle the input as "normal" navigation input
	navigationInput=`head -1 $input_storage_file`;
	forwardUserInput=true;
	return 0;
    fi
}
#
# ******************************************************************************************************************
#
# This function is used to enter navigation mode
# In this mode the user can repeatedly visit directories by only entering the name of each folder (absolute path, relative path - including wildcards)
# It is also possible to access other functions like history/favorites, goto previous directory etc.
function navigate {
    # accesses the menu with the most recent executed commands, user can choose one entry to execute that command again
    function goToCommandMenu {
	if [[ ! -s "$c_hist_file" ]]; then
	    echo "There are no entries in the command history menu.";
	    return 1;
	fi
	clear;
	echo 'COMMAND HISTORY';
	echo;
	if [[ $editPrevCommand == false ]]; then
	    echo '-- EXECUTE COMMAND --';
	else
	    echo '-- EDIT COMMAND --';
	fi
	echo;
	cat -n "$c_hist_file";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter command number.';
	echo 'Enter ! to quit';
	echo;
	read -e cmdNr;
	# check the input entered by user and perform the required actions
	tempVar=`wc -l "$c_hist_file"`;
	currentNumberOfCmdEntries=`echo $tempVar | cut -f 1 -d ' '`;
	if [[ $cmdNr =~  $nonNegativeInteger     ]] &&
	   [[ $cmdNr -ge 1                       ]] &&
	   [[ $cmdNr -le $currentNumberOfCmdEntries ]]; then
	    clear;
	    commandHistoryEntry=`sed "$cmdNr"'q;d' "$c_hist_file"`;
	    if [[ $editPrevCommand == false ]]; then
		# execute the actual command from command history menu
		commandToExecute="$commandHistoryEntry";
		executeNewCommand;
	    else
		# edit the chosen command prior to executing
		editAndExecCmdFromHistory;
	    fi
	elif [[ $cmdNr == '!' ]]; then
	    clear;
	    echo 'No command chosen.';
	else
	    # handle the input as "normal" navigation input
	    navigationInput="$cmdNr";
	    forwardUserInput=true;
	fi
    }
    # erases the command history (this operation is done independently of the one that erases navigation history)
    function clearCommandHistory {
	> "$c_r_hist_file";
	> "$c_hist_file";
	echo 'Content of command history menu has been erased.';
    }
    # helper function for executing a new shell command (either with new input or based on a previous command)
    function executeNewCommand {
	# memorize the command in a separate variable (otherwise the $command variable will be modified by eval in case the command is a script)
	prevCommand="$commandToExecute";
	if [[ ${#commandToExecute} -ge $minNrOfCmdChars ]]; then
	    "$pythonPath" "$scriptDir"/.update_individual_command_history_files.py "$commandToExecute";
	    #sort the file so user can spot the commands easier
	    "$pythonPath" "$scriptDir"/.consolidate_command_history.py
	fi
	echo "Command is being executed: $commandToExecute";
	echo '--------------------------';
	eval "$commandToExecute";
	commandStatus=$?;
	echo '--------------------------';
	echo -n 'Command ';
	if [[ 0 != $commandStatus ]]; then
	    commandResult='finished with errors';
	else
	    commandResult='finished successfully';
	fi
	echo "$commandResult! Scroll up to check output (if any) if it exceeds the screen.";
    }
    # helper function for executing previous shell command again
    function repeatPrevCommand {
	if [[ -z $prevCommand ]]; then
	    echo 'No shell command previously executed';
	else
	    echo "Command is being executed: $prevCommand";
	    echo '--------------------------';
	    eval "$prevCommand";
	    commandStatus=$?;
	    echo '--------------------------';
	    echo -n 'Command ';
	    if [[ 0 != $commandStatus ]]; then
		commandResult='finished with errors';
	    else
		commandResult='finished successfully';
	    fi
	    echo "$commandResult! Scroll up to check output (if any) if it exceeds the screen.";
	fi
    }
    # helper function that feeds a previously executed command (from command history) to user for editing prior to having it executed
    function editAndExecCmdFromHistory {
	echo 'Please edit the below command and hit ENTER to execute';
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$commandHistoryEntry" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    executeNewCommand;
	fi
    }
    # helper function used for displaying the content of the current directory
    function displayCurrentDirContent {
	# get number of items from current directory
	ls | tee "$aux_temp_file" | head -"$maxNrOfItems" > "$temp_file";
	tempOutput=`wc -l "$aux_temp_file"`;
	nrOfItems=`echo $tempOutput | cut -f 1 -d ' '`;
	> "$aux_temp_file";
	# limit the number of characters displayed for each item so current directory content is correctly displayed
	# (otherwise the content might be too much expanded)
	while read currentEntry;
	do
	    if [[ ${#currentEntry} -gt $maxNrOfChars ]]; then
		if [[ -d "$currentEntry" ]]; then
		    echo "${currentEntry:0:$maxNrOfChars}../" >> "$aux_temp_file";
		else
		    echo "${currentEntry:0:$maxNrOfChars}..." >> "$aux_temp_file";
		fi
	    else
		if [[ -d "$currentEntry" ]]; then
		    echo "$currentEntry"'/' >> "$aux_temp_file";
		else
		    echo "$currentEntry" >> "$aux_temp_file";
		fi
	    fi
	done < "$temp_file"
	rm "$temp_file";
	column "$aux_temp_file";
	echo;
	if [[ $nrOfItems -gt $maxNrOfItems ]]; then
	    echo "Number of items contained in the directory ($nrOfItems) exceeds the displayed ones ($maxNrOfItems)! Type :ls -p | less to display all directory items.";
	else
	    echo "Number of items contained in the directory: $nrOfItems";
	fi
	rm "$aux_temp_file";
    }
    # helper function used for displaying the help menu of the navigation mode
    function displayHelp {
	helpMenu='';
	helpMenu="$helpMenu"'echo "Navigation functions";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "For executing any shell command please enter : followed by the command string.";';
	helpMenu="$helpMenu"'echo "For example enter :ls -l to list the contents of the current directory in detail.";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "Other useful navigation options: ";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo ":-    -  repeat last executed shell command (if any)";';
	helpMenu="$helpMenu"'echo ":     -  enter a shell command based on previous command (only available in BASH 4)";';
	helpMenu="$helpMenu"'echo ":<    -  enter command history menu";';
	helpMenu="$helpMenu"'echo "::    -  enter command history menu to edit a previous command (only available in BASH 4)";';
	helpMenu="$helpMenu"'echo ":<>   -  clear command history";';
	helpMenu="$helpMenu"'echo "<     -  enter history menu";';
	helpMenu="$helpMenu"'echo ">     -  enter favorites menu";';
	helpMenu="$helpMenu"'echo ",     -  go to the previously visited directory";';
	helpMenu="$helpMenu"'echo "+>    -  add current directory to favorites";';
	helpMenu="$helpMenu"'echo "->    -  remove a directory from favorites";';
	helpMenu="$helpMenu"'echo "!<>   -  clear navigation history";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "For direct navigation to a history or favorites menu entry please enter < or > followed by a number";';
	helpMenu="$helpMenu"'echo "Please do not put any spaces between operator and number";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "Press q to exit";';
	helpMenu="$helpMenu"'echo;';
	eval "$helpMenu" | less;
	echo 'You exited navigation help menu';
    }
    # helper function for handling general input (new commands or directories to navigate to)
    function handleGeneralInput {
	# A string starting with ':' will be treated as a command (alternative way of entering new commands from navigation mode)
	if [[ ${navigationInput:0:1} == ':' ]]; then
	    commandToExecute=${navigationInput:1};
	    executeNewCommand;
	else
	    goToDir `echo "$navigationInput"`;
	fi
    }
    # helper function for executing a new command based on the string of the previously executed shell command
    function execCommandBasedOnPrevInput {
	if [[ -z "$prevCommand" ]]; then
	    echo 'No shell command previously executed. Enter a new command';
	else
	    echo 'Please edit the below command and hit ENTER to execute';
	fi
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$prevCommand" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    executeNewCommand;
	fi
    }
    # helper function used for displaying the "home screen" of the navigation function
    function displayGeneralNavigationOutput {
	echo;
	echo '****************************************************************************************************';
	echo;
	echo 'Current directory:';
	echo `pwd`;
	echo;
	echo '----------------------------------------------------------------------------------------------------';
	echo;
	echo "Directory content (hidden items are excluded):";
	echo;
	displayCurrentDirContent;
	echo;
	echo '----------------------------------------------------------------------------------------------------';
	echo;
	echo -n "Last executed shell command";
	if [[ -z "$prevCommand" ]]; then
	    echo ':';
	    echo 'none';
	else
	    echo " ($commandResult):";
	    echo "$prevCommand";
	fi
	echo;
	echo '****************************************************************************************************';
	echo;
	echo 'Enter the path of the directory you want to visit (press ENTER to return to the home dir).';
	echo 'Enter ? for the list of of available commands or ! to quit navigation mode.';
	echo;
    }
    # helper function that handles all possible options entered by user in navigation mode
    function handleNavigationOption {
	case $navigationInput in
	'?')
	    displayHelp;
	    ;;
	':-')
	    repeatPrevCommand;
	    ;;
	':')
	    execCommandBasedOnPrevInput;
	    ;;
	':<')
	    editPrevCommand=false;
	    goToCommandMenu;
	    ;;
	'::')
	    editPrevCommand=true;
	    goToCommandMenu;
	    ;;
	':<>')
	    clearCommandHistory;
	    ;;
	'<'*)
	    secondArg=${navigationInput:1};
	    goToMenu -h "$secondArg";
	    ;;
	'>'*)
	    secondArg=${navigationInput:1};
	    goToMenu -f "$secondArg";
	    ;;
	',')
	    goToPrevDir;
	    ;;
	'+>')
	    addToFavorites;
	    ;;
	'->')
	    removeFromFavorites;
	    ;;
	'!<>')
	    "$pythonPath" "$scriptDir"/.clear_history.py;
	    ;;
	'!')
	    return 0;
	    ;;
	*)
	    handleGeneralInput;
	    ;;
	esac
    }
    # stores last executed shell command (if any) and its result
    prevCommand='';
    commandResult='';
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	displayGeneralNavigationOutput;
	read -e navigationInput;
	# stay in this loop as long as the function called by choosing a navigation option forwards user input back to the navigate function
	while [[ '1' == '1' ]]; do
	    clear;
	    handleNavigationOption;
	    if [[ $forwardUserInput == true ]]; then
		forwardUserInput=false;
	    else
		break;
	    fi
	done
	if [[ $navigationInput == '!' ]]; then
	    echo 'You exited navigation mode.';
	    unset -f goToCommandMenu;
	    unset -f clearCommandHistory;
	    unset -f executeNewCommand;
	    unset -f repeatPrevCommand;
	    unset -f editAndExecCmdFromHistory;
	    unset -f displayCurrentDirContent;
	    unset -f displayHelp;
	    unset -f handleGeneralInput;
	    unset -f execCommandBasedOnPrevInput;
	    unset -f displayGeneralNavigationOutput;
	    unset -f handleNavigationOption;
	    return 0;
	fi
    done
}
#
#
#
#
# *****************************************************************************************************************
#
# Disable all "private" functions so they cannot be accessed by user from CLI
# These functions are only helper functions that are used by the global functions in order to perform specific operations
# Direct access from user side might cause unexpected behavior
# In addition to this "global disable" (which is run only once when the file is loaded by shell) the private functions also need to be disabled each time they are used
#
unset -f formatFileContent;
unset -f displayHistory;
unset -f displayFavorites;
unset -f handleMissingDirectory;
unset -f displayFavoritesFile;
unset -f goToCommandMenu;
unset -f clearCommandHistory;
unset -f executeNewCommand;
unset -f repeatPrevCommand;
unset -f editAndExecCmdFromHistory;
unset -f displayCurrentDirContent;
unset -f displayHelp;
unset -f execCommandBasedOnPrevInput;
unset -f handleGeneralInput;
unset -f displayGeneralNavigationOutput;
unset -f handleNavigationOption;
#
#
#
#
# *****************************************************************************************************************
#
# Naming conventions used in this file:
# - variables containing path of working files (e.g. $p_hist_file): to be named using Python convention (underscore)
# - all other variables and all functions: to be named using lower camelCase convention
